$#include "Node.h"

enum CreateMode
{
    REPLICATED = 0,
    LOCAL = 1
};

class Node : public Serializable
{
    Node(Context* context);
    virtual ~Node();

    bool SaveXML(Serializer& dest) const;
    void SetName(const String& name);
    void SetPosition(const Vector3& position);
    void SetRotation(const Quaternion& rotation);
    void SetDirection(const Vector3& direction);
    void SetScale(float scale);
    void SetScale(const Vector3& scale);
    void SetTransform(const Vector3& position, const Quaternion& rotation);
    void SetTransform(const Vector3& position, const Quaternion& rotation, float scale);
    void SetTransform(const Vector3& position, const Quaternion& rotation, const Vector3& scale);
    void SetWorldPosition(const Vector3& position);
    void SetWorldRotation(const Quaternion& rotation);
    void SetWorldDirection(const Vector3& direction);
    void SetWorldScale(float scale);
    void SetWorldScale(const Vector3& scale);
    void SetWorldTransform(const Vector3& position, const Quaternion& rotation);
    void SetWorldTransform(const Vector3& position, const Quaternion& rotation, float scale);
    void SetWorldTransform(const Vector3& position, const Quaternion& rotation, const Vector3& scale);
    void Translate(const Vector3& delta);
    void TranslateRelative(const Vector3& delta);
    
    void Rotate(const Quaternion& delta, bool fixedAxis = false);
    void Pitch(float angle, bool fixedAxis = false);
    void Yaw(float angle, bool fixedAxis = false);
    void Roll(float angle, bool fixedAxis = false);
    void LookAt(const Vector3& target, const Vector3& upAxis = Vector3::UP);
    
    void Scale(float scale);
    void Scale(const Vector3& scale);
    void SetEnabled(bool enable);
    void SetEnabled(bool enable, bool recursive);
    void SetOwner(Connection* owner);
    void MarkDirty();
    
    Node* CreateChild(const String& name = String::EMPTY, CreateMode mode = REPLICATED, unsigned id = 0);
    
    void AddChild(Node* node);
    void RemoveChild(Node* node);
    void RemoveAllChildren();
    void RemoveChildren(bool removeReplicated, bool removeLocal, bool recursive);
    void RemoveComponent(Component* component);
    void RemoveComponent(ShortStringHash type);
    void RemoveComponent(const char* type);
    
    void RemoveAllComponents();
    void RemoveComponents(bool removeReplicated, bool removeLocal);
    
    Node* Clone(CreateMode mode = REPLICATED);
    
    void Remove();
    void SetParent(Node* parent);
    void SetVar(ShortStringHash key, const Variant& value);
    void AddListener(Component* component);
    void RemoveListener(Component* component);
    
    // template <class T> T* CreateComponent(CreateMode mode = REPLICATED, unsigned id = 0);
    Component* CreateComponent(const char* type, CreateMode mode = REPLICATED, unsigned id = 0);
    
    unsigned GetID() const;
    const String& GetName() const;
    StringHash GetNameHash() const;
    Node* GetParent() const;
    Scene* GetScene() const;
    bool IsEnabled() const;
    Connection* GetOwner() const;
    const Vector3& GetPosition() const;
    const Quaternion& GetRotation() const;
    Vector3 GetDirection() const;
    const Vector3& GetScale() const;
    Matrix3x4 GetTransform() const;

    Vector3 GetWorldPosition() const;
    Quaternion GetWorldRotation() const;
    Vector3 GetWorldDirection() const;
    Vector3 GetWorldScale() const;
    const Matrix3x4& GetWorldTransform() const;
    Vector3 LocalToWorld(const Vector3& position) const;
    Vector3 LocalToWorld(const Vector4& vector) const;
    Vector3 WorldToLocal(const Vector3& position) const;
    Vector3 WorldToLocal(const Vector4& vector) const;
    bool IsDirty() const;
    
    unsigned GetNumChildren(bool recursive = false) const;
    Node* GetChild(unsigned index) const;
    Node* GetChild(const String& name, bool recursive = false) const;
    Node* GetChild(const char* name, bool recursive = false) const;
    Node* GetChild(StringHash nameHash, bool recursive = false) const;
    
    unsigned GetNumComponents() const;
    unsigned GetNumNetworkComponents() const;
    
    bool HasComponent(ShortStringHash type) const;
    bool HasComponent(const char* type) const;
    
    const Variant& GetVar(ShortStringHash key) const;
    const VariantMap& GetVars() const;
    
    // template <class T> T* GetComponent() const;
    Component* GetComponent(const char* type) const;
    
    void SetID(unsigned id);
    void SetScene(Scene* scene);
    void ResetScene();
    
    bool Load(Deserializer& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false, CreateMode mode = REPLICATED);
    bool LoadXML(const XMLElement& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false, CreateMode mode = REPLICATED);

    Node* CreateChild(unsigned id, CreateMode mode);
    void AddComponent(Component* component, unsigned id, CreateMode mode);
    
    tolua_property__get_set unsigned ID;
    tolua_property__get_set String& name;
    tolua_readonly tolua_property__get_set StringHash nameHash;
    tolua_property__get_set Node* parent;
    tolua_property__get_set Scene* scene;
    tolua_property__is_set bool enabled;
    tolua_property__get_set Connection* owner;
    tolua_property__get_set Vector3& position;
    tolua_property__get_set Quaternion& rotation;
    tolua_property__get_set Vector3 direction;
    tolua_property__get_set Vector3& scale;
    tolua_readonly tolua_property__get_set Matrix3x4 transform;
    tolua_property__get_set Vector3 worldPosition;
    tolua_property__get_set Quaternion worldRotation;
    tolua_property__get_set Vector3 worldDirection;
    tolua_property__get_set Vector3 worldScale;
    tolua_readonly tolua_property__get_set Matrix3x4& worldTransform;
    tolua_readonly tolua_property__is_set bool dirty;
    tolua_readonly tolua_property__get_set unsigned numComponents;
    tolua_readonly tolua_property__get_set unsigned numNetworkComponents;
};

${

// Disable generated CreateComponent funciton.
#define TOLUA_DISABLE_tolua_SceneLuaAPI_Node_CreateComponent00

static int tolua_SceneLuaAPI_Node_CreateComponent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Node",0,&tolua_err) ||
     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  const char* type = ((const char*)  tolua_tostring(tolua_S,2,0));
  CreateMode mode = ((CreateMode) (int)  tolua_tonumber(tolua_S,3,REPLICATED));
  unsigned id = ((unsigned)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CreateComponent'", NULL);
#endif
  {
   Component* tolua_ret = (Component*)  self->CreateComponent(type,mode,id);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,type);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CreateComponent'.",&tolua_err);
 return 0;
#endif
}

// Disable generated GetComponent funciton.
#define TOLUA_DISABLE_tolua_SceneLuaAPI_Node_GetComponent00

static int tolua_SceneLuaAPI_Node_GetComponent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Node",0,&tolua_err) ||
     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Node* self = (const Node*)  tolua_tousertype(tolua_S,1,0);
  const char* type = ((const char*)  tolua_tostring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetComponent'", NULL);
#endif
  {
   Component* tolua_ret = (Component*)  self->GetComponent(type);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,type);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetComponent'.",&tolua_err);
 return 0;
#endif
}

$}
