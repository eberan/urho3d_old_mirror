$#include "Color.h"

/// RGBA color.
class Color
{
public:
    /// Construct with default values (opaque white.)
    Color() :
        r_(1.0f),
        g_(1.0f),
        b_(1.0f),
        a_(1.0f)
    {
    }
    
    /// Copy-construct from another color.
    Color(const Color& color) :
        r_(color.r_),
        g_(color.g_),
        b_(color.b_),
        a_(color.a_)
    {
    }
    
    /// Construct from another color and modify the alpha.
    Color(const Color& color, float a) :
        r_(color.r_),
        g_(color.g_),
        b_(color.b_),
        a_(a)
    {
    }
    
    /// Construct from RGB values and set alpha fully opaque.
    Color(float r, float g, float b) :
        r_(r),
        g_(g),
        b_(b),
        a_(1.0f)
    {
    }
    
    /// Construct from RGBA values.
    Color(float r, float g, float b, float a) :
        r_(r),
        g_(g),
        b_(b),
        a_(a)
    {
    }
    /// Test for equality with another color.
    bool operator == (const Color& rhs) const { return Equals(r_, rhs.r_) && Equals(g_, rhs.g_) && Equals(b_, rhs.b_) && Equals(a_, rhs.a_); }
    /// Multiply with a scalar.
    Color operator * (float rhs) const { return Color(r_ * rhs, g_ * rhs, b_ * rhs, a_ * rhs); }
    /// Add a color.
    Color operator + (const Color& rhs) const { return Color(r_ + rhs.r_, g_ + rhs.g_, b_ + rhs.b_, a_ + rhs.a_); }
    
    
        
    /// Return RGB values as a Vector3.
    Vector3 RGBValues() const { return Vector3(r_, g_, b_); }
    /// Return approximate intensity.
    float Intensity() const { return RGBValues().DotProduct(Vector3(0.333f, 0.333f, 0.333f)); }
    
    /// Linear interpolation with another color.
    Color Lerp(const Color& rhs, float t) const
    {
        float invT = 1.0f - t;
        return Color(
            r_ * invT + rhs.r_ * t,
            g_ * invT + rhs.g_ * t,
            b_ * invT + rhs.b_ * t,
            a_ * invT + rhs.a_ * t
        );
    }
    
    /// Return color packed to a 32-bit integer. Components are clamped to [0, 1] range.
    unsigned ToUInt() const
    {
        unsigned r = Clamp(((int)(r_ * 255.0f)), 0, 255);
        unsigned g = Clamp(((int)(g_ * 255.0f)), 0, 255);
        unsigned b = Clamp(((int)(b_ * 255.0f)), 0, 255);
        unsigned a = Clamp(((int)(a_ * 255.0f)), 0, 255);
        return (a << 24) | (b << 16) | (g << 8) | r;
    }
    
    /// Return as a four-dimensional vector.
    Vector4 ToVector4() const { return Vector4(r_, g_, b_, a_); }
    
    /// Return as string.
    String ToString() const;
    /// Red value.
    float r_ @ r;
    /// Green value.
    float g_ @ g;
    /// Blue value.
    float b_ @ b;
    /// Alpha value.
    float a_ @ a;
    
    /// Opaque white color.
    static const Color WHITE;
    /// Opaque yellow color.
    static const Color YELLOW;
    /// Opaque red color.
    static const Color RED;
    /// Opaque green color.
    static const Color GREEN;
    /// Opaque green color.
    static const Color BLUE;
    /// Opaque black color.
    static const Color BLACK;
    /// Transparent color (black with no alpha).
    static const Color TRANSPARENT;
};
